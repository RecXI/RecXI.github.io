<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RecXI个人博客</title>
  <subtitle>喜欢实验，喜欢探究本质</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-08-24T02:59:01.916Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>RecXI</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>锟斤拷烫烫屯</title>
    <link href="http://yoursite.com/2017/08/24/%E9%94%9F%E6%96%A4%E6%8B%B7%E7%83%AB%E7%83%AB%E5%B1%AF/"/>
    <id>http://yoursite.com/2017/08/24/锟斤拷烫烫屯/</id>
    <published>2017-08-24T02:59:01.000Z</published>
    <updated>2017-08-24T02:59:01.916Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>辨析python中的bytes和str类型</title>
    <link href="http://yoursite.com/2017/08/23/%E8%BE%A8%E6%9E%90python%E4%B8%AD%E7%9A%84bytes%E5%92%8Cstr%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2017/08/23/辨析python中的bytes和str类型/</id>
    <published>2017-08-23T02:34:47.000Z</published>
    <updated>2017-08-24T03:07:50.064Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>一篇描述该问题的精彩博文：<a href="http://www.cnblogs.com/chownjy/p/6625299.html" target="_blank" rel="external">被引用博文</a></p>
</blockquote>
<p> 下面是一些本人的理解，对这篇博文进行补充</p>
<blockquote>
<p>引用一句话：编码问题号称编程领域的<strong>幽灵</strong>，如果你不弄懂它，它会折磨你一辈子</p>
</blockquote>
<p><strong>【注】</strong>下面的讨论建立在这个前提之上：bytes可解码为文本，非多媒体二进制序列。</p>
<hr>
<h1 id="底层思维和面向对象思维相结合即可理解两者差异："><a href="#底层思维和面向对象思维相结合即可理解两者差异：" class="headerlink" title="底层思维和面向对象思维相结合即可理解两者差异："></a>底层思维和面向对象思维相结合即可理解两者差异：</h1><pre><code>1. 如果仅仅有底层思维，那么比较容易陷入一个逻辑陷阱：

    bytes和str没有区别，因为本质上都是二进制序列。

2. 其实这种理解并没有问题，但是这种理解片面了，因为没有加上面向对象的思维：

    bytes和str是不同类型的对象。

    对象是数据的容器。封装着不同的属性和方法

    字符串/字节序列  本身的二进制序列只是封装在容器中的一部分

3. 举个例子：&quot;py&quot;，b&quot;py&quot;。假设内部的编码模式一致(UTF-8,ASCII,GBK。。whatever)，假设为：0101101010100011

    看上去完全一样，但这只是部分相同。

    &quot;py&quot;是字符串，封装了encode方法，

    b&quot;py&quot;是字节，封装了decode方法

    仅仅从它两封装着不同的方法就可以看出：他们是不同类型的对象。所以在很多场景下无法兼容，必须转换。
</code></pre><h1 id="str和bytes相互转换："><a href="#str和bytes相互转换：" class="headerlink" title="str和bytes相互转换："></a>str和bytes相互转换：</h1><pre><code>1. 理解了差异之后，转换就显得没有那么僵硬了

    ---无非就是不同类型对象之间的转换（最开始我完全不能理解为什么两个一样的东西要进行转换）

    ---str转换为bytes的过程称为编码

       bytes转换为str的过程称为解码/译码

2. 转换的方式有两种：

    1）对象式的：decode，encode
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s1 = u&quot;中文&quot;</div><div class="line">#将Unicode重新编码为GBK</div><div class="line">b1 = s1.encode(&quot;gbk&quot;)</div><div class="line">s2 = b1.decode(&quot;gbk&quot;)</div></pre></td></tr></table></figure>
<pre><code>2)过程式的：str(byte,encoding=),bytes(str,encoding=) 

        注意到两个的位置参数都为encoding，并没有decoding
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s1 = &quot;中&quot;</div><div class="line">b1 = bytes(s1,encoding=&quot;utf-8&quot;)</div><div class="line">s2 = str(b1,encoding=&quot;utf-8&quot;)</div><div class="line">s1 == s2</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一篇描述该问题的精彩博文：&lt;a href=&quot;http://www.cnblogs.com/chownjy/p/6625299.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;被引用博文&lt;/a&gt;&lt;/p&gt;
&lt;/blockquo
    
    </summary>
    
      <category term="字符编码问题" scheme="http://yoursite.com/categories/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="字符编码" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>枚举类型</title>
    <link href="http://yoursite.com/2017/08/17/%E6%9E%9A%E4%B8%BE/"/>
    <id>http://yoursite.com/2017/08/17/枚举/</id>
    <published>2017-08-17T07:47:23.000Z</published>
    <updated>2017-08-16T07:50:40.374Z</updated>
    
    <content type="html"><![CDATA[<p>枚举类型是学任何一门语言都会接触到的一个语法点。这个语法点在教材上出现得很突兀，使用频率不高。</p>
<p>而且初学时，不容易get到它的应用场景，所以往往都选择跳过。（其实问题并不大，这不是一个很重要的语法点）</p>
<p>但既然是通用语法的一部分，我们还是很有必要（闲得发慌）去探究一下它的原理与作用。</p>
<h1 id="枚举类型的原理"><a href="#枚举类型的原理" class="headerlink" title="枚举类型的原理"></a>枚举类型的原理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">以C++为例：</div><div class="line">enum 枚举名&#123; </div><div class="line">     标识符[=整型常数], </div><div class="line">     标识符[=整型常数], </div><div class="line">... </div><div class="line">    标识符[=整型常数]</div><div class="line">&#125; 枚举变量;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">实验代码：</div><div class="line">typedef enum &#123;</div><div class="line">    down = 1,</div><div class="line">    right,</div><div class="line">    up,</div><div class="line">    left,</div><div class="line">&#125; Direction;</div><div class="line"></div><div class="line">//相当于把1,2两个整数分别赋给两个枚举变量</div><div class="line">Direction dir_d = down; </div><div class="line">Direction dir_r = right;</div></pre></td></tr></table></figure>
<p>我们发现枚举变量与两个语法很像：<br>①宏定义 #define down 1  （不分配空间）<br>②整型常量 const int down = 1;   （分配空间）</p>
<p>不管枚举常量的原理是哪一种，有一点是确定的：</p>
<h3 id="枚举是一种”批量化定义”"><a href="#枚举是一种”批量化定义”" class="headerlink" title="枚举是一种”批量化定义”"></a>枚举是一种”批量化定义”</h3><p>宏与整型常量的区别主要在于内存空间的分配问题上，形式上很像</p>
<p>我们通过另外一个实验可以大致确定：</p>
<h3 id="枚举的原理是”批量宏定义”而不是常量定义。"><a href="#枚举的原理是”批量宏定义”而不是常量定义。" class="headerlink" title="枚举的原理是”批量宏定义”而不是常量定义。"></a>枚举的原理是”批量宏定义”而不是常量定义。</h3><h3 id="一个枚举类相当于封装了一组有规律的宏"><a href="#一个枚举类相当于封装了一组有规律的宏" class="headerlink" title="一个枚举类相当于封装了一组有规律的宏"></a>一个枚举类相当于封装了一组有规律的宏</h3><h3 id="一个枚举类的实例变量只能在这组宏里面选一个套上。"><a href="#一个枚举类的实例变量只能在这组宏里面选一个套上。" class="headerlink" title="一个枚举类的实例变量只能在这组宏里面选一个套上。"></a>一个枚举类的实例变量只能在这组宏里面选一个套上。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">实验的思路是：查看数值改变后的错误信息：</div><div class="line"></div><div class="line">const_test = 2;  //整型常量</div><div class="line">macro_test = 2;	 //整型常量</div><div class="line">down = 2;        //枚举常量</div><div class="line"></div><div class="line">cout&lt;&lt;const_test&lt;&lt;endl;</div><div class="line">cout&lt;&lt;const_test&lt;&lt;endl;</div><div class="line">cout&lt;&lt;const_test&lt;&lt;endl;</div></pre></td></tr></table></figure>
<p><img src="/2017/08/17/枚举/1.png" alt=""></p>
<h1 id="枚举的作用："><a href="#枚举的作用：" class="headerlink" title="枚举的作用："></a>枚举的作用：</h1><h3 id="增强程序的可读性，即：面向语义编程"><a href="#增强程序的可读性，即：面向语义编程" class="headerlink" title="增强程序的可读性，即：面向语义编程"></a>增强程序的可读性，即：面向语义编程</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;枚举类型是学任何一门语言都会接触到的一个语法点。这个语法点在教材上出现得很突兀，使用频率不高。&lt;/p&gt;
&lt;p&gt;而且初学时，不容易get到它的应用场景，所以往往都选择跳过。（其实问题并不大，这不是一个很重要的语法点）&lt;/p&gt;
&lt;p&gt;但既然是通用语法的一部分，我们还是很有必要（
    
    </summary>
    
    
      <category term="通用基础语法" scheme="http://yoursite.com/tags/%E9%80%9A%E7%94%A8%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>指针和引用在语法层面存在的意义</title>
    <link href="http://yoursite.com/2017/08/16/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E5%9C%A8%E8%AF%AD%E6%B3%95%E5%B1%82%E9%9D%A2%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89/"/>
    <id>http://yoursite.com/2017/08/16/指针和引用在语法层面存在的意义/</id>
    <published>2017-08-16T04:20:27.000Z</published>
    <updated>2017-08-23T02:50:57.964Z</updated>
    
    <content type="html"><![CDATA[<p>这是现阶段的个人理解，不一定正确。</p>
<p>C和C++在语法层面支持甚至依赖于指针，而Java在语法层面却没有指针<br>【注】其实Java本质上还是依赖于指针，封装屏蔽了这些底层细节。</p>
<p>那么抛开底层本质，从语法层面的角度分析：为什么C，C++要<br>依赖指针（C++的引用同理）。</p>
<h1 id="一。必须手动管理内存的地方"><a href="#一。必须手动管理内存的地方" class="headerlink" title="一。必须手动管理内存的地方"></a>一。必须手动管理内存的地方</h1><p>其实很多教材上也说了：C，C++给了开发者操控逻辑内存的自由，比如<br>动态内存管理。<br>动态申请内存空间这样的操作必须用指针（注意是必须）。<br>当然，这些必须的东西我们很熟悉，都是固定的语法。<br>但我们更关注指针在必须层面以外的还有什么存在的意义，这才是灵性编程的关键。</p>
<h1 id="二。函数指针是一家"><a href="#二。函数指针是一家" class="headerlink" title="二。函数指针是一家"></a>二。函数指针是一家</h1><p>这是本文更加关注的一个点：<br>C，C++支持面向过程的范式，这样的范式离不开函数。<br>函数是个特殊的盒子，而指针、引用可以解决函数的特殊性带来的问题。</p>
<p>函数的特殊性很多，这里简单举几点，不深究：<br>①函数被压栈以后是个独立的工作区间，有自己独立的变量空间。<br> 局部变量依附于对应函数。</p>
<p>②函数默认为值传递，其实指针传递也属于值传递（传地址值），而引用传递属于实体传递<br>  值传递和实体传递的区别在于：是否为参数额外开辟了内存空间<br> 在值传递时，形参只是实参的副本。所以想要在函数中访问实参必须通过指针或者引用传递</p>
<p>③函数返回值默认为值返回。<br>  要想返回实体，必须通过指针或者引用。<br>  而且这个返回的实体只能是全局变量，或者静态局部变量。<br>  非静态局部变量禁止被返回。</p>
<p>而java是个纯粹的面向对象的语言，OOP范式用方法代替函数，而且GC的存在让开发者<br>不用手动管理内存，所以在语法层面完全可以扔掉指针。（再次强调抛开底层本质）</p>
<p>不过初学时可能会疑惑：在Java中如何实现两数交换？<br>其实很简单，直接交换不用函数就行了嘛（手动滑稽）。或者你可以用OOP的方式：<br>封装成类，再调用方法实现。</p>
<h1 id="三。总结："><a href="#三。总结：" class="headerlink" title="三。总结："></a>三。总结：</h1><p>java在语法层面可以完全抛弃指针，不影响任何实现。<br>而C，C++不能，①因为它们有很多必须使用指针的地方—比如动态内存管理<br>                ②另外：它们需要指针来解决函数的特殊性所带来的问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是现阶段的个人理解，不一定正确。&lt;/p&gt;
&lt;p&gt;C和C++在语法层面支持甚至依赖于指针，而Java在语法层面却没有指针&lt;br&gt;【注】其实Java本质上还是依赖于指针，封装屏蔽了这些底层细节。&lt;/p&gt;
&lt;p&gt;那么抛开底层本质，从语法层面的角度分析：为什么C，C++要&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++基础语法" scheme="http://yoursite.com/tags/C-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C++标准流重定向</title>
    <link href="http://yoursite.com/2017/08/15/C-%E6%A0%87%E5%87%86%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://yoursite.com/2017/08/15/C-标准流重定向/</id>
    <published>2017-08-15T15:03:22.000Z</published>
    <updated>2017-08-16T07:32:27.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标准输入-输出流的重定向"><a href="#标准输入-输出流的重定向" class="headerlink" title="标准输入/输出流的重定向"></a>标准输入/输出流的重定向</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">遵循&quot;借还原则&quot;的编程原则，在最后进行了重定向恢复。</div><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;fstream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line"> </div><div class="line">void f()</div><div class="line">&#123;</div><div class="line">    std::string line;</div><div class="line">    while(std::getline(std::cin, line))  //input from the file in.txt</div><div class="line">    &#123;</div><div class="line">        std::cout &lt;&lt; line &lt;&lt; &quot;\n&quot;;   //output to the file out.txt</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    std::ifstream in(&quot;in.txt&quot;);</div><div class="line">    std::streambuf *cinbuf = std::cin.rdbuf(); //save old buf</div><div class="line">    std::cin.rdbuf(in.rdbuf()); //redirect std::cin to in.txt!</div><div class="line"> </div><div class="line">    std::ofstream out(&quot;out.txt&quot;);</div><div class="line">    std::streambuf *coutbuf = std::cout.rdbuf(); //save old buf</div><div class="line">    std::cout.rdbuf(out.rdbuf()); //redirect std::cout to out.txt!</div><div class="line"> </div><div class="line">    std::string word;</div><div class="line">    std::cin &gt;&gt; word;           //input from the file in.txt</div><div class="line">    std::cout &lt;&lt; word &lt;&lt; &quot;  &quot;;  //output to the file out.txt</div><div class="line"> </div><div class="line">    f(); //call function</div><div class="line"> </div><div class="line"> </div><div class="line">    std::cin.rdbuf(cinbuf);   //reset to standard input again</div><div class="line">    std::cout.rdbuf(coutbuf); //reset to standard output again</div><div class="line"> </div><div class="line">    std::cin &gt;&gt; word;   //input from the standard input</div><div class="line">    std::cout &lt;&lt; word;  //output to the standard input</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="扩展：标准错误-日志流的重定向"><a href="#扩展：标准错误-日志流的重定向" class="headerlink" title="扩展：标准错误,日志流的重定向"></a>扩展：标准错误,日志流的重定向</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">其实原理是一样的，这里简化书写，并省略借还原则：</div><div class="line"></div><div class="line">ofstream err(&quot;err.txt&quot;);</div><div class="line">cerr.rdbuf(err.rdbuf()); //redirect std::cout to out.txt!</div><div class="line"></div><div class="line">ofstream logger(&quot;log.txt&quot;);</div><div class="line">clog.rdbuf(logger.rdbuf()); //redirect std::cout to out.txt!</div><div class="line"></div><div class="line">cerr&lt;&lt;&quot;cerr&quot;&lt;&lt;endl;</div><div class="line">clog&lt;&lt;&quot;clog&quot;&lt;&lt;endl;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;标准输入-输出流的重定向&quot;&gt;&lt;a href=&quot;#标准输入-输出流的重定向&quot; class=&quot;headerlink&quot; title=&quot;标准输入/输出流的重定向&quot;&gt;&lt;/a&gt;标准输入/输出流的重定向&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++基础语法" scheme="http://yoursite.com/tags/C-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
</feed>
